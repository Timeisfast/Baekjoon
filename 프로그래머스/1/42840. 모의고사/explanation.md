## 1. 리스트 * n과 슬라이싱
- **목적**: 일정한 패턴을 정해진 길이만큼 반복하는 리스트 생성
- **예시**:
```
p1 = ([1, 2, 3, 4, 5] * 2000)[:len(answers)]
```
- **설명**:   
  `[1, 2, 3, 4, 5]`를 2000번 반복한 후, 실제 정답 리스트(`answers`)의 길이만큼 잘라서 사용   
  충분히 반복해 두고 필요한 만큼만 자르는 방식

## 2. zip(a, b)
- **목적**: 두 개의 리스트를 병렬로 묶어서 `(a[i], b[i])` 형태의 튜플을 생성
- **예시**:
```
zip(p1, answers)
```
- **설명**:   
  `p1`, `answers`의 각 원소를 하나씩 묶어서 튜플로 반환하는 iterator 생성   
  채점처럼 두 리스트를 한 줄로 비교할 때 자주 사용

## 3. 리스트 컴프리헨션과 조건 비교
- **목적**: 각 원소를 비교한 결과로 True/False 리스트 생성
- **예시**:
```
[(x == y) for x, y in zip(p1, answers)]
```
- **설명**:   
  `x`와 `y`가 같으면 `True`, 다르면 `False` -> Boolean 리스트로 반환   
  이후 `sum()`과 함께 쓰면 정답 개수 세는 데 활용 가능

## 4. sum(boolean_list)
- **목적**: `True = 1`, `False = 0`으로 간주되어, 전체 합은 `True`의 개수와 같음
- **예시**:
```
p1_correct = sum([(x == y) for x, y in zip(p1, answers)])
```
- **설명**:   
  맞춘 문제 수 계산. 리스트 컴프리헨션과 함께 쓰면 코드가 매우 간결해짐
