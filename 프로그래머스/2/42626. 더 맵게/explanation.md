## 1. `heapq.heapify()`로 최소 힙 구성
- **목적**: 리스트를 최소 힙(min-heap)으로 변환하여 빠르게 최소값에 접근 가능하게 함
- **해당 코드**:
```
heapify(scoville)
```
- **설명**:   
  `heapify()`는 리스트를 `O(N)` 시간에 힙 구조로 바꿔줌   
  힙은 루트 노드가 가장 작은 값을 갖도록 정렬된 이진 트리 구조   
  `scoville[0]`이 항상 가장 작은 값이 되므로 효율적   

## 2. `heappop()`으로 최소 2개 추출, 새 음식 섞기
- **목적**: 가장 맵지 않은 두 음식 추출 후 새로운 음식으로 만들어 다시 삽입
- **해당 코드**:
```
n1 = heappop(scoville)
n2 = heappop(scoville)
heappush(scoville, n1 + n2 * 2)
```
- **설명**:   
  가장 작은 `n1`과 그 다음 작은 `n2`를 추출   
  섞은 결과 = `n1 + (n2 * 2)`   
  새로 만든 음식도 힙에 다시 넣어야 하므로 `heappush()` 사용   
  -> 최소 힙 유지하면서 음식 조합을 반복   

## 3. 모든 음식이 `K` 이상일 때까지 반복
- **목적**: 루프 조건을 통해 가장 맵지 않은 음식이 `K` 이상일 때까지 섞음
- **해당 코드**:
```
while scoville[0] < K and len(scoville) > 1:
```
- **설명**:   
  `scoville[0]`: 현재 가장 맵지 않은 음식   
  길이가 1일 때는 더 이상 섞을 수 없으므로 탈출 조건   
  → 모든 음식이 `K` 이상이 되지 않으면 `-1` 반환

### tip 힙(Heap) 기반 풀이의 장점
- **시간복잡도**: `N log N`   
  -> 매번 삽입/삭제에 `O(log N)` → 총 최대 `N`번 반복
- **효율성**: `sort()`나 `min()`을 매번 쓰는 것보다 훨씬 빠름
- **간결함**: `heapq` 모듈 함수만으로 필요한 연산 처리 가능

### tip `heapq` 주요 함수 요약
|함수|설명|
|---|---|
|`heapify(list)`|리스트를 최소 힙으로 변환 (`O(N)`)|
|`heappop(heap)`|최소값 제거 후 반환 (`O(log N)`)|
|`heappush(heap, val)`|값을 힙에 삽입 (`O(log N)`)|
|`heap[0]`|현재 힙의 최소값 (루트 노드)|
